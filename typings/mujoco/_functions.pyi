import flags
import mujoco._structs
import numpy

def mj_Euler(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_RungeKutta(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, N: int) -> None: ...
def mj_addContact(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, con: mujoco._structs.MjContact) -> int: ...
def mj_addM(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, dst: numpy.ndarray[numpy.float64[m, 1], flags.writeable], rownnz: numpy.ndarray[numpy.int32[m, 1], flags.writeable], rowadr: numpy.ndarray[numpy.int32[m, 1], flags.writeable], colind: numpy.ndarray[numpy.int32[m, 1], flags.writeable]) -> None: ...
def mj_angmomMat(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, mat: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], body: int) -> None: ...
def mj_applyFT(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, force: numpy.ndarray[numpy.float64[3, 1]], torque: numpy.ndarray[numpy.float64[3, 1]], point: numpy.ndarray[numpy.float64[3, 1]], body: int, qfrc_target: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> None: ...
def mj_camlight(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_checkAcc(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_checkPos(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_checkVel(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_collision(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_comPos(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_comVel(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_compareFwdInv(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_constraintUpdate(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jar: numpy.ndarray[numpy.float64[m, 1]], cost: numpy.ndarray[numpy.float64[1, 1], flags.writeable] | None, flg_coneHessian: int) -> None: ...
def mj_contactForce(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, id: int, result: numpy.ndarray[numpy.float64[6, 1], flags.writeable]) -> None: ...
def mj_crb(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_defaultLROpt(opt: mujoco._structs.MjLROpt) -> None: ...
def mj_defaultOption(opt: mujoco._structs.MjOption) -> None: ...
def mj_defaultSolRefImp(solref: float, solimp: float) -> None: ...
def mj_defaultVisual(vis: mujoco._structs.MjVisual) -> None: ...
def mj_differentiatePos(m: mujoco._structs.MjModel, qvel: numpy.ndarray[numpy.float64[m, 1], flags.writeable], dt: float, qpos1: numpy.ndarray[numpy.float64[m, 1]], qpos2: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mj_energyPos(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_energyVel(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_factorM(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_flex(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_forward(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_forwardSkip(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, skipstage: int, skipsensor: int) -> None: ...
def mj_fullM(m: mujoco._structs.MjModel, dst: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], M: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mj_fwdAcceleration(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_fwdActuation(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_fwdConstraint(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_fwdPosition(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_fwdVelocity(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_getState(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, state: numpy.ndarray[numpy.float64[m, 1], flags.writeable], spec: int) -> None: ...
def mj_getTotalmass(m: mujoco._structs.MjModel) -> float: ...
def mj_id2name(m: mujoco._structs.MjModel, type: int, id: int) -> str: ...
def mj_implicit(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_integratePos(m: mujoco._structs.MjModel, qpos: numpy.ndarray[numpy.float64[m, 1], flags.writeable], qvel: numpy.ndarray[numpy.float64[m, 1]], dt: float) -> None: ...
def mj_invConstraint(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_invPosition(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_invVelocity(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_inverse(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_inverseSkip(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, skipstage: int, skipsensor: int) -> None: ...
def mj_isDual(m: mujoco._structs.MjModel) -> int: ...
def mj_isPyramidal(m: mujoco._structs.MjModel) -> int: ...
def mj_isSparse(m: mujoco._structs.MjModel) -> int: ...
def mj_island(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_jac(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jacp: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, jacr: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, point: numpy.ndarray[numpy.float64[3, 1]], body: int) -> None: ...
def mj_jacBody(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jacp: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, jacr: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, body: int) -> None: ...
def mj_jacBodyCom(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jacp: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, jacr: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, body: int) -> None: ...
def mj_jacGeom(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jacp: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, jacr: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, geom: int) -> None: ...
def mj_jacPointAxis(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jacPoint: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, jacAxis: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, point: numpy.ndarray[numpy.float64[3, 1]], axis: numpy.ndarray[numpy.float64[3, 1]], body: int) -> None: ...
def mj_jacSite(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jacp: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, jacr: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, site: int) -> None: ...
def mj_jacSubtreeCom(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, jacp: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, body: int) -> None: ...
def mj_kinematics(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_loadAllPluginLibraries(directory: str) -> None: ...
def mj_loadPluginLibrary(path: str) -> None: ...
def mj_local2Global(d: mujoco._structs.MjData, xpos: numpy.ndarray[numpy.float64[3, 1], flags.writeable], xmat: numpy.ndarray[numpy.float64[9, 1], flags.writeable], pos: numpy.ndarray[numpy.float64[3, 1]], quat: numpy.ndarray[numpy.float64[4, 1]], body: int, sameframe: int) -> None: ...
def mj_makeConstraint(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_mulJacTVec(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mj_mulJacVec(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mj_mulM(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mj_mulM2(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mj_multiRay(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, pnt: numpy.ndarray[numpy.float64[3, 1]], vec: numpy.ndarray[numpy.float64[m, 1]], geomgroup: numpy.ndarray[numpy.uint8[6, 1]] | None, flg_static: int, bodyexclude: int, geomid: numpy.ndarray[numpy.int32[m, 1], flags.writeable], dist: numpy.ndarray[numpy.float64[m, 1], flags.writeable], nray: int, cutoff: float) -> None: ...
def mj_name2id(m: mujoco._structs.MjModel, type: int, name: str) -> int: ...
def mj_normalizeQuat(m: mujoco._structs.MjModel, qpos: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> None: ...
def mj_objectAcceleration(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, objtype: int, objid: int, res: numpy.ndarray[numpy.float64[6, 1], flags.writeable], flg_local: int) -> None: ...
def mj_objectVelocity(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, objtype: int, objid: int, res: numpy.ndarray[numpy.float64[6, 1], flags.writeable], flg_local: int) -> None: ...
def mj_passive(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_printData(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, filename: str) -> None: ...
def mj_printFormattedData(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, filename: str, float_format: str) -> None: ...
def mj_printFormattedModel(m: mujoco._structs.MjModel, filename: str, float_format: str) -> None: ...
def mj_printModel(m: mujoco._structs.MjModel, filename: str) -> None: ...
def mj_printSchema(flg_html: bool, flg_pad: bool) -> str: ...
def mj_projectConstraint(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_ray(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, pnt: numpy.ndarray[numpy.float64[3, 1]], vec: numpy.ndarray[numpy.float64[3, 1]], geomgroup: numpy.ndarray[numpy.uint8[6, 1]] | None, flg_static: int, bodyexclude: int, geomid: numpy.ndarray[numpy.int32[1, 1], flags.writeable]) -> float: ...
def mj_rayHfield(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, geomid: int, pnt: numpy.ndarray[numpy.float64[3, 1]], vec: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
def mj_rayMesh(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, geomid: int, pnt: numpy.ndarray[numpy.float64[3, 1]], vec: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
def mj_referenceConstraint(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_resetCallbacks() -> None: ...
def mj_resetData(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_resetDataDebug(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, debug_value: int) -> None: ...
def mj_resetDataKeyframe(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, key: int) -> None: ...
def mj_rne(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, flg_acc: int, result: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> None: ...
def mj_rnePostConstraint(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_saveLastXML(filename: str, m: mujoco._structs.MjModel) -> None: ...
def mj_saveModel(m: mujoco._structs.MjModel, filename: str | None = ..., buffer: numpy.ndarray[numpy.uint8[m, 1], flags.writeable] | None = ...) -> None: ...
def mj_sensorAcc(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_sensorPos(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_sensorVel(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_setConst(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_setLengthRange(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, index: int, opt: mujoco._structs.MjLROpt) -> None: ...
def mj_setState(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, state: numpy.ndarray[numpy.float64[m, 1], flags.writeable], spec: int) -> None: ...
def mj_setTotalmass(m: mujoco._structs.MjModel, newmass: float) -> None: ...
def mj_sizeModel(m: mujoco._structs.MjModel) -> int: ...
def mj_solveM(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, x: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], y: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mj_solveM2(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, x: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], y: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mj_stateSize(m: mujoco._structs.MjModel, spec: int) -> int: ...
def mj_step(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, nstep: int = ...) -> None: ...
def mj_step1(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_step2(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_subtreeVel(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_tendon(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_transmission(m: mujoco._structs.MjModel, d: mujoco._structs.MjData) -> None: ...
def mj_version() -> int: ...
def mj_versionString() -> str: ...
def mjd_inverseFD(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, eps: float, flg_actuation: int, DfDq: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, DfDv: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, DfDa: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, DsDq: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, DsDv: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, DsDa: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, DmDq: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None) -> None: ...
def mjd_quatIntegrate(vel: numpy.ndarray[numpy.float64[3, 1]], scale: float, Dquat: numpy.ndarray[numpy.float64[9, 1], flags.writeable], Dvel: numpy.ndarray[numpy.float64[9, 1], flags.writeable], Dscale: numpy.ndarray[numpy.float64[3, 1], flags.writeable]) -> None: ...
def mjd_subQuat(qa: numpy.ndarray[numpy.float64[m, 1]], qb: numpy.ndarray[numpy.float64[m, 1]], Da: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, Db: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None) -> None: ...
def mjd_transitionFD(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, eps: float, flg_centered: int, A: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, B: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, C: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None, D: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous] | None) -> None: ...
def mju_Halton(index: int, base: int) -> float: ...
def mju_L1(vec: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> float: ...
def mju_add(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec1: numpy.ndarray[numpy.float64[m, 1]], vec2: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_add3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec1: numpy.ndarray[numpy.float64[3, 1]], vec2: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_addScl(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec1: numpy.ndarray[numpy.float64[m, 1]], vec2: numpy.ndarray[numpy.float64[m, 1]], scl: float) -> None: ...
def mju_addScl3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec1: numpy.ndarray[numpy.float64[3, 1]], vec2: numpy.ndarray[numpy.float64[3, 1]], scl: float) -> None: ...
def mju_addTo(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_addTo3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_addToScl(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]], scl: float) -> None: ...
def mju_addToScl3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]], scl: float) -> None: ...
def mju_axisAngle2Quat(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable], axis: numpy.ndarray[numpy.float64[3, 1]], angle: float) -> None: ...
def mju_band2Dense(res: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mat: numpy.ndarray[numpy.float64[m, 1]], ntotal: int, nband: int, ndense: int, flg_sym: int) -> None: ...
def mju_bandDiag(i: int, ntotal: int, nband: int, ndense: int) -> int: ...
def mju_bandMulMatVec(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], vec: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], ntotal: int, nband: int, ndense: int, nvec: int, flg_sym: int) -> None: ...
def mju_boxQP(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], R: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], index: numpy.ndarray[numpy.int32[m, 1], flags.writeable] | None, H: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], g: numpy.ndarray[numpy.float64[m, 1]], lower: numpy.ndarray[numpy.float64[m, 1]] | None, upper: numpy.ndarray[numpy.float64[m, 1]] | None) -> int: ...
def mju_cholFactor(mat: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mindiag: float) -> int: ...
def mju_cholFactorBand(mat: numpy.ndarray[numpy.float64[m, 1], flags.writeable], ntotal: int, nband: int, ndense: int, diagadd: float, diagmul: float) -> float: ...
def mju_cholSolve(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_cholSolveBand(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[m, 1]], vec: numpy.ndarray[numpy.float64[m, 1]], ntotal: int, nband: int, ndense: int) -> None: ...
def mju_cholUpdate(mat: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], x: numpy.ndarray[numpy.float64[m, 1], flags.writeable], flg_plus: int) -> int: ...
def mju_clip(x: float, min: float, max: float) -> float: ...
def mju_copy(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_copy3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], data: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_copy4(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable], data: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_cross(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], a: numpy.ndarray[numpy.float64[3, 1]], b: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_d2n(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_decodePyramid(force: numpy.ndarray[numpy.float64[m, 1], flags.writeable], pyramid: numpy.ndarray[numpy.float64[m, 1]], mu: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_dense2Band(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], ntotal: int, nband: int, ndense: int) -> None: ...
def mju_derivQuat(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable], quat: numpy.ndarray[numpy.float64[4, 1]], vel: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_dist3(pos1: numpy.ndarray[numpy.float64[3, 1]], pos2: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
def mju_dot(vec1: numpy.ndarray[numpy.float64[m, 1]], vec2: numpy.ndarray[numpy.float64[m, 1]]) -> float: ...
def mju_dot3(vec1: numpy.ndarray[numpy.float64[3, 1]], vec2: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
def mju_eig3(eigval: numpy.ndarray[numpy.float64[3, 1], flags.writeable], eigvec: numpy.ndarray[numpy.float64[9, 1], flags.writeable], quat: numpy.ndarray[numpy.float64[4, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[9, 1]]) -> int: ...
def mju_encodePyramid(pyramid: numpy.ndarray[numpy.float64[m, 1], flags.writeable], force: numpy.ndarray[numpy.float64[m, 1]], mu: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_euler2Quat(quat: numpy.ndarray[numpy.float64[4, 1], flags.writeable], euler: numpy.ndarray[numpy.float64[3, 1]], seq: str) -> None: ...
def mju_eye(mat: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous]) -> None: ...
def mju_f2n(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float32[m, 1]]) -> None: ...
def mju_fill(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], val: float) -> None: ...
def mju_insertionSort(list: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> None: ...
def mju_insertionSortInt(list: numpy.ndarray[numpy.int32[m, 1], flags.writeable]) -> None: ...
def mju_isBad(x: float) -> int: ...
def mju_isZero(vec: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> int: ...
def mju_mat2Quat(quat: numpy.ndarray[numpy.float64[4, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[9, 1]]) -> None: ...
def mju_max(a: float, b: float) -> float: ...
def mju_min(a: float, b: float) -> float: ...
def mju_mulMatMat(res: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mat1: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], mat2: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mju_mulMatMatT(res: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mat1: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], mat2: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mju_mulMatTMat(res: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mat1: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], mat2: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mju_mulMatTVec(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_mulMatVec(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_mulPose(posres: numpy.ndarray[numpy.float64[3, 1], flags.writeable], quatres: numpy.ndarray[numpy.float64[4, 1], flags.writeable], pos1: numpy.ndarray[numpy.float64[3, 1]], quat1: numpy.ndarray[numpy.float64[4, 1]], pos2: numpy.ndarray[numpy.float64[3, 1]], quat2: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_mulQuat(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable], quat1: numpy.ndarray[numpy.float64[4, 1]], quat2: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_mulQuatAxis(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable], quat: numpy.ndarray[numpy.float64[4, 1]], axis: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_mulVecMatVec(vec1: numpy.ndarray[numpy.float64[m, 1]], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], vec2: numpy.ndarray[numpy.float64[m, 1]]) -> float: ...
def mju_muscleBias(len: float, lengthrange: numpy.ndarray[numpy.float64[2, 1]], acc0: float, prm: numpy.ndarray[numpy.float64[9, 1]]) -> float: ...
def mju_muscleDynamics(ctrl: float, act: float, prm: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
def mju_muscleGain(len: float, vel: float, lengthrange: numpy.ndarray[numpy.float64[2, 1]], acc0: float, prm: numpy.ndarray[numpy.float64[9, 1]]) -> float: ...
def mju_n2d(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_n2f(res: numpy.ndarray[numpy.float32[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_negPose(posres: numpy.ndarray[numpy.float64[3, 1], flags.writeable], quatres: numpy.ndarray[numpy.float64[4, 1], flags.writeable], pos: numpy.ndarray[numpy.float64[3, 1]], quat: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_negQuat(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable], quat: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_norm(res: numpy.ndarray[numpy.float64[m, 1]]) -> float: ...
def mju_norm3(vec: numpy.ndarray[numpy.float64[3, 1]]) -> float: ...
def mju_normalize(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> float: ...
def mju_normalize3(vec: numpy.ndarray[numpy.float64[3, 1], flags.writeable]) -> float: ...
def mju_normalize4(vec: numpy.ndarray[numpy.float64[4, 1], flags.writeable]) -> float: ...
def mju_printMat(mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mju_printMatSparse(mat: numpy.ndarray[numpy.float64[m, 1]], rownnz: numpy.ndarray[numpy.int32[m, 1]], rowadr: numpy.ndarray[numpy.int32[m, 1]], colind: numpy.ndarray[numpy.int32[m, 1]]) -> None: ...
def mju_quat2Mat(res: numpy.ndarray[numpy.float64[9, 1], flags.writeable], quat: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_quat2Vel(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], quat: numpy.ndarray[numpy.float64[4, 1]], dt: float) -> None: ...
def mju_quatIntegrate(quat: numpy.ndarray[numpy.float64[4, 1], flags.writeable], vel: numpy.ndarray[numpy.float64[3, 1]], scale: float) -> None: ...
def mju_quatZ2Vec(quat: numpy.ndarray[numpy.float64[4, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_rayFlex(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, flex_layer: int, flg_vert: int, flg_edge: int, flg_face: int, flg_skin: int, flexid: int, pnt: float, vec: float, vertid: numpy.ndarray[numpy.int32[1, 1], flags.writeable]) -> float: ...
def mju_rayGeom(pos: numpy.ndarray[numpy.float64[3, 1]], mat: numpy.ndarray[numpy.float64[9, 1]], size: numpy.ndarray[numpy.float64[3, 1]], pnt: numpy.ndarray[numpy.float64[3, 1]], vec: numpy.ndarray[numpy.float64[3, 1]], geomtype: int) -> float: ...
def mju_raySkin(nface: int, nvert: int, face: int, vert: float, pnt: numpy.ndarray[numpy.float64[3, 1]], vec: numpy.ndarray[numpy.float64[3, 1]], vertid: numpy.ndarray[numpy.int32[1, 1], flags.writeable]) -> float: ...
def mju_rotVecMat(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]], mat: numpy.ndarray[numpy.float64[9, 1]]) -> None: ...
def mju_rotVecMatT(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]], mat: numpy.ndarray[numpy.float64[9, 1]]) -> None: ...
def mju_rotVecQuat(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]], quat: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_round(x: float) -> int: ...
def mju_scl(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]], scl: float) -> None: ...
def mju_scl3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]], scl: float) -> None: ...
def mju_sigmoid(x: float) -> float: ...
def mju_sign(x: float) -> float: ...
def mju_springDamper(pos0: float, vel0: float, Kp: float, Kv: float, dt: float) -> float: ...
def mju_sqrMatTD(res: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous], diag: numpy.ndarray[numpy.float64[m, 1], flags.writeable] | None) -> None: ...
def mju_standardNormal(num2: float | None) -> float: ...
def mju_str2Type(str: str) -> int: ...
def mju_sub(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec1: numpy.ndarray[numpy.float64[m, 1]], vec2: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_sub3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec1: numpy.ndarray[numpy.float64[3, 1]], vec2: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_subFrom(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[m, 1]]) -> None: ...
def mju_subFrom3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_subQuat(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], qa: numpy.ndarray[numpy.float64[4, 1]], qb: numpy.ndarray[numpy.float64[4, 1]]) -> None: ...
def mju_sum(vec: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> float: ...
def mju_symmetrize(res: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mju_transformSpatial(res: numpy.ndarray[numpy.float64[6, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[6, 1]], flg_force: int, newpos: numpy.ndarray[numpy.float64[3, 1]], oldpos: numpy.ndarray[numpy.float64[3, 1]], rotnew2old: numpy.ndarray[numpy.float64[9, 1]]) -> None: ...
def mju_transpose(res: numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.c_contiguous], mat: numpy.ndarray[numpy.float64[m, n], flags.c_contiguous]) -> None: ...
def mju_trnVecPose(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], pos: numpy.ndarray[numpy.float64[3, 1]], quat: numpy.ndarray[numpy.float64[4, 1]], vec: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mju_type2Str(type: int) -> str: ...
def mju_unit4(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable]) -> None: ...
def mju_warningText(warning: int, info: int) -> str: ...
def mju_writeLog(type: str, msg: str) -> None: ...
def mju_writeNumBytes(nbytes: int) -> str: ...
def mju_zero(res: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -> None: ...
def mju_zero3(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable]) -> None: ...
def mju_zero4(res: numpy.ndarray[numpy.float64[4, 1], flags.writeable]) -> None: ...
def mjv_addGeoms(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, opt: mujoco._structs.MjvOption, pert: mujoco._structs.MjvPerturb, catmask: int, scn: mujoco._structs.MjvScene) -> None: ...
def mjv_alignToCamera(res: numpy.ndarray[numpy.float64[3, 1], flags.writeable], vec: numpy.ndarray[numpy.float64[3, 1]], forward: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mjv_applyPerturbForce(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, pert: mujoco._structs.MjvPerturb) -> None: ...
def mjv_applyPerturbPose(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, pert: mujoco._structs.MjvPerturb, flg_paused: int) -> None: ...
def mjv_cameraInModel(headpos: numpy.ndarray[numpy.float64[3, 1], flags.writeable], forward: numpy.ndarray[numpy.float64[3, 1], flags.writeable], up: numpy.ndarray[numpy.float64[3, 1], flags.writeable], scn: mujoco._structs.MjvScene) -> None: ...
def mjv_cameraInRoom(headpos: numpy.ndarray[numpy.float64[3, 1], flags.writeable], forward: numpy.ndarray[numpy.float64[3, 1], flags.writeable], up: numpy.ndarray[numpy.float64[3, 1], flags.writeable], scn: mujoco._structs.MjvScene) -> None: ...
def mjv_connector(geom: mujoco._structs.MjvGeom, type: int, width: float, from_: numpy.ndarray[numpy.float64[3, 1]], to: numpy.ndarray[numpy.float64[3, 1]]) -> None: ...
def mjv_defaultCamera(cam: mujoco._structs.MjvCamera) -> None: ...
def mjv_defaultFigure(fig: mujoco._structs.MjvFigure) -> None: ...
def mjv_defaultFreeCamera(m: mujoco._structs.MjModel, cam: mujoco._structs.MjvCamera) -> None: ...
def mjv_defaultOption(opt: mujoco._structs.MjvOption) -> None: ...
def mjv_defaultPerturb(pert: mujoco._structs.MjvPerturb) -> None: ...
def mjv_frustumHeight(scn: mujoco._structs.MjvScene) -> float: ...
def mjv_initGeom(geom: mujoco._structs.MjvGeom, type: int, size: numpy.ndarray[numpy.float64[3, 1]], pos: numpy.ndarray[numpy.float64[3, 1]], mat: numpy.ndarray[numpy.float64[9, 1]], rgba: numpy.ndarray[numpy.float32[4, 1]]) -> None: ...
def mjv_initPerturb(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, scn: mujoco._structs.MjvScene, pert: mujoco._structs.MjvPerturb) -> None: ...
def mjv_makeConnector(geom: mujoco._structs.MjvGeom, type: int, width: float, a0: float, a1: float, a2: float, b0: float, b1: float, b2: float) -> None: ...
def mjv_makeLights(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, scn: mujoco._structs.MjvScene) -> None: ...
def mjv_model2room(roompos: numpy.ndarray[numpy.float64[3, 1], flags.writeable], roomquat: numpy.ndarray[numpy.float64[4, 1], flags.writeable], modelpos: numpy.ndarray[numpy.float64[3, 1]], modelquat: numpy.ndarray[numpy.float64[4, 1]], scn: mujoco._structs.MjvScene) -> None: ...
def mjv_moveCamera(m: mujoco._structs.MjModel, action: int, reldx: float, reldy: float, scn: mujoco._structs.MjvScene, cam: mujoco._structs.MjvCamera) -> None: ...
def mjv_moveModel(m: mujoco._structs.MjModel, action: int, reldx: float, reldy: float, roomup: numpy.ndarray[numpy.float64[3, 1]], scn: mujoco._structs.MjvScene) -> None: ...
def mjv_movePerturb(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, action: int, reldx: float, reldy: float, scn: mujoco._structs.MjvScene, pert: mujoco._structs.MjvPerturb) -> None: ...
def mjv_room2model(modelpos: numpy.ndarray[numpy.float64[3, 1], flags.writeable], modelquat: numpy.ndarray[numpy.float64[4, 1], flags.writeable], roompos: numpy.ndarray[numpy.float64[3, 1]], roomquat: numpy.ndarray[numpy.float64[4, 1]], scn: mujoco._structs.MjvScene) -> None: ...
def mjv_select(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, vopt: mujoco._structs.MjvOption, aspectratio: float, relx: float, rely: float, scn: mujoco._structs.MjvScene, selpnt: numpy.ndarray[numpy.float64[3, 1], flags.writeable], geomid: numpy.ndarray[numpy.int32[1, 1], flags.writeable], flexid: numpy.ndarray[numpy.int32[1, 1], flags.writeable], skinid: numpy.ndarray[numpy.int32[1, 1], flags.writeable]) -> int: ...
def mjv_updateCamera(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, cam: mujoco._structs.MjvCamera, scn: mujoco._structs.MjvScene) -> None: ...
def mjv_updateScene(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, opt: mujoco._structs.MjvOption, pert: mujoco._structs.MjvPerturb | None, cam: mujoco._structs.MjvCamera, catmask: int, scn: mujoco._structs.MjvScene) -> None: ...
def mjv_updateSkin(m: mujoco._structs.MjModel, d: mujoco._structs.MjData, scn: mujoco._structs.MjvScene) -> None: ...
